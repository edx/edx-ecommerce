import decimal
import logging

import stripe
import stripe.error
from django.core.urlresolvers import reverse
import mock

from oscar.core.loading import get_model
from oscar.apps.checkout.views import PaymentError
from oscar.apps.payment.exceptions import GatewayError
from ecommerce.extensions.payment.processors.stripe import StripeProcessor
from ecommerce.extensions.payment.tests.processors.mixins import PaymentProcessorTestCaseMixin
from ecommerce.tests.testcases import TestCase

PaymentEventType = get_model('order', 'PaymentEventType')
PaymentProcessorResponse = get_model('payment', 'PaymentProcessorResponse')
SourceType = get_model('payment', 'SourceType')

log = logging.getLogger(__name__)


class StripeTests(PaymentProcessorTestCaseMixin, TestCase):

    processor_class = StripeProcessor
    processor_name = 'stripe'

    def test_dollars_to_cents(self):
        self.assertEqual("12340", self.processor.dollars_to_cents(decimal.Decimal("123.4")))

    def test_get_total(self):
        basket = mock.MagicMock()
        basket.total_incl_tax = decimal.Decimal("12.34")
        self.assertEqual("1234", self.processor.get_total(basket))

    def test_get_transaction_parameters(self):
        with self.assertRaises(NotImplementedError):
            # No need to fill parameters, it will raise unconditionally
            self.processor.get_transaction_parameters(None, None)

    def test_get_script_context(self):
        config = self.processor.configuration
        expected_context = {
            'stripe_publishable_key': config['publishable_key'],
            'stripe_process_payment_url':
                reverse('stripe_checkout', kwargs={'basket': self.basket.pk}),
            'stripe_amount_cents': self.processor.get_total(self.basket),
            'stripe_image_url': config['image_url'],
            'stripe_currency': self.basket.currency,
            'stripe_user_email': self.basket.owner.email,
            'stripe_payment_description': self.processor.get_description(self.basket),
            'button_label': self.processor.payment_label,
            "basket": self.basket
        }

        self.assertDictEqual(
            expected_context,
            self.processor.get_script_context(self.basket, self.basket.owner)
        )

    def test_handle_processor_response(self):
        """
        Tests a valid payment.
        """
        # Id we got from checkout.js -- a stripe token
        token_id = "token_id"
        # Id of a successful charge: generated by stripe client.
        charge_id = "charge_id"
        charge = stripe.Charge(id=charge_id, foo="foo", bar="bar")

        with mock.patch.object(stripe.Charge, 'create', return_value=charge) as charge_create:
            source, payment_event = self.processor.handle_processor_response(
                token_id,
                self.basket
            )

        charge_create.assert_called_once_with(
            amount=self.processor.get_total(self.basket),
            currency=self.basket.currency,
            source=token_id,
            api_key=self.processor.configuration['secret_key'],
            description=self.processor.get_description(self.basket),
            metadata={
                'basket_pk': self.basket.pk,
                'basket_sku': self.basket.order_number,
                'username': self.basket.owner.username
            }
        )

        source_type = SourceType.objects.get(code=self.processor.NAME)
        payment_type = PaymentEventType.objects.get(code='paid')
        amount = self.basket.total_incl_tax

        # Check if source_type and payment_type are as expected:
        self.assert_basket_matches_source(
            basket=self.basket,
            source=source,
            source_type=source_type,
            reference=charge_id,
            label='Stripe'
        )
        self.assert_valid_payment_event_fields(
            payment_event=payment_event,
            amount=amount,
            payment_event_type=payment_type,
            processor_name=self.processor.NAME,
            reference=charge_id
        )

        # Check processor response is recorded:
        self.assert_processor_response_recorded(
            processor_name=self.processor.NAME,
            transaction_id=charge_id,
            response=charge,
            basket=self.basket
        )

    def test_handle_processor_response_declined(self):
        """
        Tests the test_handle_processor_response in case where payment
        is explicitly declined by Stripe.
        """
        token_id = "token_id"

        error = stripe.error.CardError("test_message", "test_param", "test_code")
        with mock.patch.object(stripe.Charge, 'create', side_effect=error):
            with self.assertRaises(PaymentError):
                self.processor.handle_processor_response(token_id, self.basket)

        # Check processor response is recorded:

        # Cant use: assert_processor_response_recorded as there is a traceback in
        # the response contents
        saved_response = PaymentProcessorResponse.objects.filter(
            processor_name=self.processor.NAME,
            transaction_id=None
        ).latest('created')

        self.assertEqual(saved_response.basket, self.basket)
        self.assertEqual(saved_response.response['type'], 'error')
        self.assertEqual(saved_response.response['operation'], 'pay')
        self.assertIn("Traceback", saved_response.response['exception_detail'])
        self.assertIn("CardError", saved_response.response['exception_detail'])

    def test_handle_processor_response_exception(self):
        """
        Tests the test_handle_processor_response in case where Stripe raises a
        an unexpected exception (ValueError)
        """
        # Assert no responses saved so far (sanity check)
        self.assertEqual(PaymentProcessorResponse.objects.count(), 0)

        token_id = "token_id"

        with mock.patch.object(stripe.Charge, 'create', side_effect=ValueError()):
            with self.assertRaises(ValueError):
                self.processor.handle_processor_response(token_id, self.basket)

        # Check if response wasn't saved (as there is no response to save)
        self.assertEqual(PaymentProcessorResponse.objects.count(), 0)

    def test_issue_credit(self):
        """
        Tests successfully issuing a credit.
        """
        refund = self.create_refund(self.processor_name)
        order = refund.order
        basket = order.basket
        refund_amount = decimal.Decimal(1234)
        currency = refund.currency
        source = order.sources.first()

        stripe_refund = stripe.Refund(
            id="re_17nVJ5G321hlVi9KF3jhDkcM",
            balance_transaction="txn_17nVJ5G321hlVi9KF3jhDkcM",
            created=1457622151,
            currency=basket.currency,
            receipt_number=basket.order_number,
            amount="123400",
            reason="requested_by_customer",
            charge=source.reference
        )

        with mock.patch.object(stripe.Refund, 'create', return_value=stripe_refund) as refund_create:
            self.processor.issue_credit(source, refund_amount, currency)

        refund_create.assert_called_once_with(
            charge=source.reference,
            api_key=self.processor.configuration['secret_key'],
            reason="requested_by_customer",
            amount="123400",
        )

        self.assert_processor_response_recorded(
            self.processor.NAME, transaction_id=source.reference,
            response=stripe_refund, basket=basket
        )

        # Tests if appropriate PaymentEvent got created
        payment_type = PaymentEventType.objects.get(code='refunded')
        order = basket.order_set.first()
        payment_event = order.payment_events.first()

        self.assert_valid_payment_event_fields(
            payment_event=payment_event,
            amount=refund_amount,
            payment_event_type=payment_type,
            processor_name=self.processor.NAME,
            reference=source.reference
        )

    def test_issue_credit_error(self):
        """
        Tests issue_credit when Stripe declined issuing the refund.
        """
        refund = self.create_refund(self.processor_name)
        order = refund.order
        basket = order.basket
        refund_amount = decimal.Decimal(1234)
        currency = refund.currency
        source = order.sources.first()

        error = stripe.error.CardError("test_message", "test_param", "test_code")
        with mock.patch.object(stripe.Refund, 'create', side_effect=error):
            with self.assertRaises(GatewayError):
                self.processor.issue_credit(source, refund_amount, currency)

        # Cant use: assert_processor_response_recorded as there is a traceback in
        # the response contents
        saved_response = PaymentProcessorResponse.objects.filter(
            processor_name=self.processor.NAME,
            transaction_id=None
        ).latest('created')

        self.assertEqual(saved_response.basket, basket)
        self.assertEqual(saved_response.response['type'], 'error')
        self.assertEqual(saved_response.response['operation'], 'refund')
        self.assertIn("Traceback", saved_response.response['exception_detail'])
        self.assertIn("CardError", saved_response.response['exception_detail'])

    def test_issue_credit_exception(self):
        """
        Tests issue_credit in case where stripe raises an unexpected exception
        (in this case Value error).
        """
        # Assert no responses saved so far (sanity check)
        self.assertEqual(PaymentProcessorResponse.objects.count(), 0)

        refund = self.create_refund(self.processor_name)
        order = refund.order
        refund_amount = decimal.Decimal(1234)
        currency = refund.currency
        source = order.sources.first()

        with mock.patch.object(stripe.Refund, 'create', side_effect=ValueError()):
            with self.assertRaises(ValueError):
                self.processor.issue_credit(source, refund_amount, currency)

        # Check if response wasn't saved
        self.assertEqual(PaymentProcessorResponse.objects.count(), 0)
